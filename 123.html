import pygame
import random

# --- 1. 定義遊戲參數與顏色 ---
pygame.init()

# 顏色定義 (RGB)
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
GRAY = (128, 128, 128)

# 方塊顏色 (7種標準 Tetris 方塊)
COLORS = [
    (0, 255, 255),  # I (青色)
    (0, 0, 255),    # J (藍色)
    (255, 165, 0),  # L (橘色)
    (255, 255, 0),  # O (黃色)
    (0, 255, 0),    # S (綠色)
    (128, 0, 128),  # T (紫色)
    (255, 0, 0)     # Z (紅色)
]

# 遊戲區域設定
GRID_WIDTH = 10
GRID_HEIGHT = 20
BLOCK_SIZE = 30
HEADER_HEIGHT = 50

# 螢幕大小
SCREEN_WIDTH = GRID_WIDTH * BLOCK_SIZE
SCREEN_HEIGHT = GRID_HEIGHT * BLOCK_SIZE + HEADER_HEIGHT
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("我的 Tetris 遊戲")

# 時鐘與速度控制
clock = pygame.time.Clock()
FALL_SPEED = 500  # 毫秒 (ms)
last_fall_time = pygame.time.get_ticks()

# 字體
font = pygame.font.Font(None, 36)

# --- 2. 定義方塊形狀 (Shape) ---

# 方塊形狀的定義 (每個形狀的四個旋轉狀態)
# 格式: [旋轉狀態 1, 旋轉狀態 2, ...]
# 每個狀態是一個包含 (x, y) 座標偏移的列表
SHAPES = [
    # I (青色)
    [[(-1, 0), (0, 0), (1, 0), (2, 0)],
     [(0, -1), (0, 0), (0, 1), (0, 2)]],
    # J (藍色)
    [[(0, -1), (0, 0), (0, 1), (-1, 1)],
     [(-1, 0), (0, 0), (1, 0), (1, -1)],
     [(0, 1), (0, 0), (0, -1), (1, -1)],
     [(1, 0), (0, 0), (-1, 0), (-1, 1)]],
    # L (橘色)
    [[(0, -1), (0, 0), (0, 1), (1, 1)],
     [(-1, 0), (0, 0), (1, 0), (1, 1)],
     [(0, 1), (0, 0), (0, -1), (-1, -1)],
     [(1, 0), (0, 0), (-1, 0), (-1, -1)]],
    # O (黃色)
    [[(0, 0), (1, 0), (0, 1), (1, 1)]], # O 型只有一個狀態
    # S (綠色)
    [[(0, 0), (1, 0), (-1, 1), (0, 1)],
     [(0, 0), (0, 1), (1, 0), (1, -1)]],
    # T (紫色)
    [[(0, 0), (-1, 0), (1, 0), (0, 1)],
     [(0, 0), (0, -1), (0, 1), (1, 0)],
     [(0, 0), (-1, 0), (1, 0), (0, -1)],
     [(0, 0), (0, -1), (0, 1), (-1, 0)]],
    # Z (紅色)
    [[(-1, 0), (0, 0), (0, 1), (1, 1)],
     [(0, -1), (0, 0), (1, 0), (1, 1)]]
]
# 

# --- 3. 遊戲場地與物件類別 ---

# 遊戲場地：一個 20x10 的二維列表，用來儲存已落下的方塊顏色索引。
# 0 表示空，1-7 表示方塊顏色索引。
grid = [[0 for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
score = 0
game_over = False

class Piece:
    def __init__(self, x, y):
        # 隨機選擇形狀和顏色
        self.shape_index = random.randint(0, len(SHAPES) - 1)
        self.color_index = self.shape_index
        self.rotation = 0
        self.x = x
        self.y = y
        self.shape = SHAPES[self.shape_index][self.rotation]
    
    def get_blocks(self):
        """計算當前方塊在 grid 上的絕對座標"""
        blocks = []
        for dx, dy in self.shape:
            blocks.append((self.x + dx, self.y + dy))
        return blocks
    
    def rotate(self):
        """切換到下一個旋轉狀態"""
        self.rotation = (self.rotation + 1) % len(SHAPES[self.shape_index])
        self.shape = SHAPES[self.shape_index][self.rotation]

# 創建第一個方塊
def new_piece():
    return Piece(GRID_WIDTH // 2, 0) # 從中間頂端生成

current_piece = new_piece()

# --- 4. 碰撞偵測與移動邏輯 ---

def is_valid_position(piece, move_x=0, move_y=0):
    """檢查方塊在移動/旋轉後是否仍然在邊界內且沒有與已落下的方塊重疊"""
    for x, y in piece.get_blocks():
        new_x = x + move_x
        new_y = y + move_y
        
        # 檢查邊界
        if not (0 <= new_x < GRID_WIDTH and new_y < GRID_HEIGHT):
            return False
        
        # 檢查是否與已落下的方塊重疊 (y < 0 發生在剛生成方塊時，不檢查)
        if new_y >= 0 and grid[new_y][new_x] != 0:
            return False
    return True

def lock_piece(piece):
    """將方塊鎖定到 grid 上，並檢查遊戲結束"""
    global game_
